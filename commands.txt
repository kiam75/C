# Using gcc
# sudo apt install build-essential
## compile with gcc
    gcc <my_programm>.c
    # With Warnings
    gcc -Wall <my_programm>.c 
## run
    ./a.out


compile_gcc="gcc -std=c11 -Wall -pedantic"

# Using clang
# sudo apt install clang
## compile with clang
    clang <my_programm>.c
    clang -Wall <my_programm>.c  

compile_clang="clang -Wall -std=c11 -pedantic"

# Wenn Programm mit Headerdatein 
# vdemir.github.io/linux/C-Compiling-and-Linking/
# zb. Verzeichisstruktur
|-- Header
|   |-- lib.c
|   |-- lib.h
|-- Intro_Functions
    |-- main.c

1.) Libary compilieren
cd Header/
gcc -c lib.c
    gcc -c lib1.c lib2.c ...
    (optional wenn mehrere libs in ein bundle)--> Static Linking
        ar rcs static.a lib1.o lib2.o
    view object files and functions:
        nm static.a
    Just view object files
        ar -t static.a
2.) Linken der Files
gcc -o my_program main.c /<FQPfad-zu-Header>/lib.o

# Compilercommands
# C Datei compilieren (in Objektcode Ã¼bersetzten)
    gcc -c <my_program>.c -o <my_progam>.o
# Dann in Maschnencode
    gcc <my_progam>.o -o my_awsome_program

# Makefile anlegen 
DEBUG_FLAGS = -g3 -O0
RELEASE_FLAGS = -DNDEBUG -O3

FLAGS = $(RELEASE_FLAGS)

preprocess:
	gcc $(FLAGS) -E IfStatement.c > Temp.c

assemble:
	gcc $(FLAGS) -S IfStatement.c

compile:
	gcc $(FLAGS) -c IfStatement.c -o IfStatement.o

linking:
	gcc $(FLAGS) IfStatement.o -o IfStatement

print_exe:
	objdump -CS IfStatement


## Jeder Schritt kann dann aufgerufen werden:
make preprocess
make assemble
make linking
# Damit kann man sich den Maschinencode ausgeben lassen
make print_exe
